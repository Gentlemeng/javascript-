##### 也许会有疑问，不过是实现一个小小的图片与加载功能，即使不引入任何模式也能办到，那么引入代理模式有什么好处呢？先抛开代理模式，编写一个更常见的图片预加载函数
```javascript
    var myImage = (function(){
        var imgNode = document.createElement('img');
        document.body.appendChild(imgNode);

        var img = new Image;
        img.onload = function(){
            imgNode.src = img.src
        }

        return {
            setSrc:function(src){
                imgNode.src = '本地loading.gif';
                img.src = src
            }
        }
    })();
    myImage.setSrc("xxx");
```
##### 为了说明代理的意义，下面我们引入一个面向对象设计的原则——单一职责原则。
##### 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外破坏。
##### 职责被定义为“引起变化的原因”。上段代码中myImage对象除了负责给img节点设置src外，还要负责预加载图片。我们在处理其中一个职责时，可能因为其强耦合性影响另外一个职责的实现。
##### 在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放-封闭原则。假如后期我们希望把预加载图片的这段代码从myImage对象里删掉。这时就不得不改动myImage对象了。
##### 实际上，我们需要的只是给img节点设置src，与加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就提现出来了，代理负责与加载图片，预加载的操作完成之后，把请求重新交给本体myImage。
##### 纵观整个程序，我们并没有改变或者增加myImage接口，但是通过代理对象，实际上给系统添加了新的行为。这是符合开放-封闭原则的。给img节点设置src和预加载这两个功能被隔离在两个对象里，他们可以各自变化而不影响对方。何况就算有一天我们不在需要预加载，那么只需要改成请求体而不是请求代理对象即可。